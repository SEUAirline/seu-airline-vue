# 前端缓存更新机制说明

## 问题背景

用户修改个人信息后，前端需要同步更新：
1. **Pinia Store** 中的用户数据
2. **localStorage** 中的持久化数据
3. **所有使用用户信息的组件**（通过响应式更新）

## 解决方案

### 1. 后端返回完整数据

#### 问题
之前后端 `PUT /user/profile` 更新成功后只返回：
```java
return ResponseEntity.ok(ApiResponse.success(null, "更新成功"));
```

前端无法获取更新后的完整用户信息（如 id, username, role 等未修改的字段）。

#### 修复
修改后端返回更新后的完整用户对象：

```java
User savedUser = userRepository.save(user);
UserProfileDTO updatedProfile = UserProfileDTO.fromUser(savedUser);
return ResponseEntity.ok(ApiResponse.success(updatedProfile, "更新成功"));
```

**返回数据示例**:
```json
{
  "code": 200,
  "message": "更新成功",
  "data": {
    "id": 2,
    "username": "passenger1",
    "fullName": "张三",
    "email": "zhangsan@example.com",
    "phone": "13900139001",
    "idCard": "320106199001011234",
    "role": "PASSENGER",
    "status": 1,
    "createdAt": "2025-11-12T10:00:00",
    "updatedAt": "2025-11-12T15:30:00"
  }
}
```

### 2. 前端正确更新 Store

#### ProfilePage.vue

**之前（❌ 问题）**:
```typescript
const handleSaveProfile = async () => {
  const response = await request.put('/user/profile', profileForm.value)
  if (response.success) {
    // 只传递表单数据，缺少 id, username, role 等字段
    userStore.updateUser(profileForm.value)
    await loadUserInfo()
  }
}
```

**现在（✅ 修复）**:
```typescript
const handleSaveProfile = async () => {
  const response = await request.put('/user/profile', profileForm.value)
  if (response.success) {
    // 使用后端返回的完整数据更新 store
    if (response.data) {
      userStore.updateUser(response.data)
      userInfo.value = response.data
    }
    isEditing.value = false
    showToast('个人信息保存成功', 'success')
  }
}
```

#### SettingsPage.vue

**修复后**:
```typescript
const saveProfile = async () => {
  saving.value = true
  try {
    const response = await request.put('/user/profile', profileForm.value)
    // 使用后端返回的完整数据
    if (response.data && response.data.data) {
      userStore.updateUser(response.data.data)
    }
  } finally {
    saving.value = false
  }
}
```

### 3. Store 更新机制

#### `src/stores/user.ts`

```typescript
function updateUser(user: Partial<User>) {
  if (currentUser.value) {
    // 合并对象：保留原有字段 + 更新传入字段
    currentUser.value = { ...currentUser.value, ...user }
    // 同步到 localStorage
    localStorage.setItem('user', JSON.stringify(currentUser.value))
  }
}
```

**工作原理**:
- `{ ...currentUser.value, ...user }` 展开运算符确保：
  - 保留原有的 `id`, `username`, `role` 等字段
  - 更新传入的 `fullName`, `idCard`, `phone` 等字段

## 数据流图

```
┌─────────────────────┐
│  用户修改个人信息    │
│  (ProfilePage)      │
└──────────┬──────────┘
           │
           ├─ PUT /user/profile (发送表单数据)
           │
           ▼
┌─────────────────────┐
│  后端保存并返回      │
│  完整用户对象        │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│ response.data       │
│ (完整 UserProfileDTO)│
└──────────┬──────────┘
           │
           ├─ userStore.updateUser(response.data)
           │
           ▼
┌─────────────────────┐
│  Pinia Store 更新   │
│  currentUser.value  │
└──────────┬──────────┘
           │
           ├─ localStorage.setItem('user', ...)
           │
           ▼
┌─────────────────────┐
│  所有订阅组件自动更新│
│  (响应式)           │
└─────────────────────┘
    │           │
    │           └─ UserCenterPage (显示用户名)
    │
    ├─ AppHeader (显示用户菜单)
    │
    └─ FlightBookPage (填充乘客信息)
```

## 缓存更新的完整流程

### 场景：用户修改手机号

1. **用户操作**: 在 ProfilePage 修改手机号 `13900139001` → `13800138000`

2. **前端发送**:
   ```json
   PUT /user/profile
   {
     "fullName": "张三",
     "phone": "13800138000",
     "email": "zhangsan@example.com",
     "idCard": "320106199001011234"
   }
   ```

3. **后端处理**:
   ```java
   user.setPhone("13800138000");
   User savedUser = userRepository.save(user);
   return ApiResponse.success(UserProfileDTO.fromUser(savedUser));
   ```

4. **后端返回**:
   ```json
   {
     "code": 200,
     "data": {
       "id": 2,
       "username": "passenger1",
       "fullName": "张三",
       "phone": "13800138000",  // 已更新
       "email": "zhangsan@example.com",
       "idCard": "320106199001011234",
       "role": "PASSENGER"
     }
   }
   ```

5. **前端更新**:
   ```typescript
   userStore.updateUser(response.data)
   // currentUser.value = {
   //   id: 2,
   //   username: "passenger1",
   //   phone: "13800138000",  ✅ 已更新
   //   ...其他字段
   // }
   ```

6. **localStorage 同步**:
   ```javascript
   localStorage.setItem('user', JSON.stringify({
     id: 2,
     username: "passenger1",
     phone: "13800138000",  ✅ 已同步
     ...
   }))
   ```

7. **所有组件自动更新** (Vue 响应式):
   - ✅ AppHeader 中的用户菜单
   - ✅ ProfilePage 中的显示信息
   - ✅ FlightBookPage 填充的乘客电话
   - ✅ UserCenterPage 中的联系方式

## 测试验证

### 测试步骤

1. **登录系统**
   ```
   用户名: passenger1
   密码: passenger123
   ```

2. **打开浏览器开发者工具**
   - Console 标签页
   - Application → Local Storage

3. **检查初始数据**
   ```javascript
   // Console
   console.log(JSON.parse(localStorage.getItem('user')))
   ```

4. **修改个人信息**
   - 访问 `/user/profile`
   - 点击"编辑资料"
   - 修改手机号：`13900139001` → `13800138888`
   - 点击"保存修改"

5. **验证缓存更新**
   ```javascript
   // Console
   const user = JSON.parse(localStorage.getItem('user'))
   console.log(user.phone)  // 应该是 "13800138888"
   ```

6. **验证其他页面同步**
   - 访问 `/flights/book/1`
   - 检查第一个乘客的手机号是否自动更新为 `13800138888`

7. **刷新页面验证持久化**
   - 按 F5 刷新页面
   - 检查用户信息是否保持最新状态

### 预期结果

✅ **保存后立即生效**
- ProfilePage 显示最新信息
- Toast 提示"个人信息保存成功"

✅ **Store 已更新**
```javascript
userStore.currentUser.phone === "13800138888"
```

✅ **localStorage 已同步**
```javascript
JSON.parse(localStorage.getItem('user')).phone === "13800138888"
```

✅ **其他页面自动同步**
- FlightBookPage 第一个乘客电话自动更新
- UserCenterPage 显示新电话

✅ **刷新后数据持久**
- 页面刷新后信息不丢失

## 可能的问题

### 问题 1: 修改后其他页面没有更新

**原因**: 组件直接从 localStorage 读取，而不是从 store 读取

**解决**: 
```typescript
// ❌ 错误
const phone = JSON.parse(localStorage.getItem('user')).phone

// ✅ 正确
import { useUserStore } from '@/stores/user'
const userStore = useUserStore()
const phone = userStore.currentUser?.phone
```

### 问题 2: 刷新后信息丢失

**原因**: Store 初始化时没有从 localStorage 恢复数据

**检查**: `src/stores/user.ts` 中的 `init()` 方法
```typescript
function init() {
  const savedUser = localStorage.getItem('user')
  const savedToken = localStorage.getItem('token')
  if (savedUser && savedToken) {
    currentUser.value = JSON.parse(savedUser)
    token.value = savedToken
  }
}
```

### 问题 3: 后端返回 null

**原因**: 后端没有修改返回完整数据

**检查**: UserController.java
```java
// ❌ 错误
return ResponseEntity.ok(ApiResponse.success(null, "更新成功"));

// ✅ 正确
UserProfileDTO updatedProfile = UserProfileDTO.fromUser(savedUser);
return ResponseEntity.ok(ApiResponse.success(updatedProfile, "更新成功"));
```

## 总结

### 核心原则

1. **单一数据源**: Pinia Store 是唯一的真实数据源
2. **后端返回完整数据**: 确保前端可以完整更新
3. **双向同步**: Store ⇄ localStorage
4. **响应式更新**: Vue 自动更新所有使用该数据的组件

### 更新流程

```
用户修改 → 发送 API → 后端保存 → 返回完整数据
    ↓
更新 Store → 同步 localStorage → 所有组件响应式更新
```

### 最佳实践

✅ **应该做**:
- 后端返回完整的用户对象
- 使用 `response.data` 更新 store
- 所有组件从 store 读取数据
- 使用 `Partial<User>` 类型确保类型安全

❌ **不应该做**:
- ~~后端返回 null~~
- ~~直接用表单数据更新 store~~
- ~~组件直接读写 localStorage~~
- ~~手动刷新页面来更新数据~~
